= A Python Cheat Sheet
polyglot-jones
v0.01, 3/1/2023

== Contents

* <<quick-start,Quick Start>>
* <<commit-standards,Commit Standards>>

* <<async-threading,Async/Threading>>
* <<bytes,Bytes>>
* <<character-sets,Character Sets>>
* <<config,Configuration>>
* <<console,Console>>
* <<containers,Containers/Enums>>
* <<data-classes,Data Classes>>
* <<data,Data Structures/Databases>>
* <<date-time,Date/Time>>
* <<dictionaries,Dictionaries>>
* <<dunder-methods,Dunder Methods>>
* <<encoding-encryption,Encoding/Encryption>>
* <<email,Email>>
* <<error-handling,Error Handling>>
* <<files,Files>>
* <<files-archives,File Archive/Compression>>
* <<graphics,Graphics>>
* <<gui,GUI>>
* <<iterators,Iterators>>
* <<lint,Lint>>
* <<lists,Lists>>
* <<logic-flow,Logic Flow>>
* <<media,Media>>
* <<networking-internet,Networking/Internet>>
* <<numbers,Numbers/Math>>
* <<operating-system,Operating System>>
* <<pathlib,PathLib>>
* <<pip-e,PIP Install Editable>>
* <<poetry,poetry>> (Installing on Windows)
* <<python-internals,Python Internals>>
* <<python-tooling,Python Tooling>>
* <<regex,RegEx>>
* <<security,Security>>
* <<sets,Sets>>
* <<sorting,Sorting>>
* <<strings,Strings/Text Processing/I18n/Unicode>>
* <<testing,Testing>>
* <<tuples,Tuples>>
* <<types,Types/Classes>>
* <<other,OTHER (TO IDENTIFY/SORT)>>



[[quick-start]]
== Quick Start

=== Sublime Plugin

See link:SUBLIME_PLUGIN_CHEAT.adoc[]

=== Stand-Alone Script

=== Any Larger Project (GUI, CLI, library)

In the following, replace PROJECT_NAME (twice):

[source,bat]
----
pip install virtualenv
pip install cookiecutter
# pip install pyscaffold pyscaffoldext-cookiecutter
cd {root folder}
putup -i PROJECT_NAME
cd PROJECT_NAME
mkdir src\models
mkdir src\utils
mkdir tools
echo "-e /proj/proj_gruntwurk/gwpycore" > requirements.txt
----

=== GUI Project

[source,bat]
----
echo "kivy # GUI " >> requirements.txt
echo "# kivy # GUI extensions" >> requirements.txt
echo "reportlab # for printing" >> requirements.txt
mkdir src\gui
mkdir src\print
----

=== CLI Project


=== Library Project

[source,bat]
----
cookiecutter https://github.com/audreyfeldroy/cookiecutter-pypackage.git
----

. Edit `setup.cfg` as necessary
. Edit `docs/conf.py` as necessary (for using sphinx to generate API docs).






[[commit-standards]]
== Commit Standards

(per https://py-pkgs.org/07-releasing-versioning.html[])
....
<type>(optional scope): Short summary in present tense.

An optional body that explains motivation for the change.

An optional footer which may note BREAKING CHANGES, and/or issues to be closed.
....

`<type>` refers to the kind of change made and is usually one of:

* *feat*: A new feature -- may trigger a minor version bump.
* *fix*: A bug fix -- may trigger a patch version bump.
* *docs*: Documentation changes.
* *style*: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc).
* *refactor*: A code change that neither fixes a bug nor adds a feature.
* *perf*: A code change that improves performance.
* *test*: Changes to the test _framework_. Changes to particular tests that correspond to a feat/fix/refactor do not need to be called out.
* *build*: Changes to the build process or tools.

`scope` is an optional keyword (e.g. a module or function name).

The text `BREAKING CHANGE` in the footer will trigger a major release.



[[async-threading]]
== Async/Threading

Python Modules:

* asyncio -- Asynchronous I/O.
* concurrent -- TBD
* multiprocessing -- Process-based parallelism.
* select -- Wait for I/O completion on multiple streams.
* selectors -- High-level I/O multiplexing.
* signal -- Set handlers for asynchronous events.
* subprocess -- Subprocess management.
* threading -- Thread-based parallelism.




[[bytes]]
== Bytes

* bytes type == immutable string
* bytearray type == mutable list

----
value = b'\xf0\xf1\xf2'
value.hex('-') ==> 'f0-f1-f2'
value.hex('_', 2) ==> 'f0_f1f2'
b'UUDDLRLRAB'.hex(' ', -4) ==> '55554444 4c524c52 4142'
----

Instantiating:

* b'' literals
* r'' literals
* bytes(10) -- a zero-filled bytes object of a specified length
* bytes(range(20)) -- from an iterable of integers
* bytes(obj) -- copying existing binary data via the buffer protocol
* bytearray() -- an empty instance
* bytearray(10) -- a zero-filled instance with a given length
* bytearray(range(20)) -- from an iterable of integers
* bytearray(b'Hi!') -- copying existing binary data via the buffer protocol
* bytes.fromhex('FFFF FFFF FFFF')
* bytes.hex()


[[character-sets]]
== Character Sets

* Charset detection with chardet -- pip install chardet







[[config]]
== Configuration

Python Modules:

* argparse -- Command-line option and argument parsing library.
* configparser -- Configuration file parser.
* *cmd* -- Build line-oriented command interpreters.
* getopt -- Portable parser for command line options; support both short and long option names.
* plistlib -- Generate and parse Apple plist files.





[[console]]
== Console

shutil.get_terminal_size(fallback=(columns, lines)) -> named tuple of type os.terminal_size






[[containers]]
== Containers/Enums

Python Modules:

* array -- Space efficient arrays of uniformly typed numeric values.
* bisect -- Array bisection algorithms for binary searching.
* collections -- Container datatypes
* enum -- Implementation of an enumeration class.
* heapq -- Heap queue algorithm (a.k.a. priority queue).
* queue -- A synchronized queue class.
* struct -- Interpret bytes as packed binary data.






[[data-classes]]
== Data Classes

The `@dataclass` decorator automatically adds special methods to a class (only if the method has not been explicitly declared).

`from dataclasses import dataclass`

`@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)`

Details: https://docs.python.org/3/library/dataclasses.html[]




[[data]]
== Data Structures/Databases

Python Modules:

* graphlib -- Functionality to operate with graph-like structures
* json -- Encode and decode the JSON format.
* *shelve* -- Python object persistence.
* sqlite3 -- A DB-API 2.0 implementation using SQLite 3.x.
* xml -- Package containing XML processing modules
* xmlrpc -- TBD





[[date-time]]
== Date/Time

Python Modules:

* calendar -- Functions for working with calendars, including some emulation of the Unix cal program.
* datetime -- Basic date and time types.
* time -- Time access and conversions.
* zoneinfo -- IANA time zone support


=== DateUtils

Details: https://pypi.org/project/python-dateutil/[]

* Relative deltas (next month, next year, next Monday, last week of month, etc) -- both ways
* Flexible recurrence rules
* Generic (fuzzy) parsing of dates in almost any string format
* More

----
from dateutil.parser import parse
logline = 'INFO 2020-01-01T00:00:01 Happy new year, human.'
timestamp = parse(logline, fuzzy=True)
print(timestamp)
# 2020-01-01 00:00:01
----

=== DateTime

`import datetime`

In the following, _dt_ is short for `datetime`:

* dt.MINYEAR
* dt.MAXYEAR
* class dt.date
* class dt.time
* class dt.dt
* class dt.timedelta
* class dt.timezone

All are immutable, hashable, efficiently pickled.

* class dt.dt(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0)

* classmethod dt.today()
* classmethod dt.now()
* classmethod dt.fromisoformat(date_string)  # YYYY-MM-DD[\*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]] (where * is any single char)
* classmethod dt.strptime() -- parse formatted

* dt.min # -> dt(MINYEAR, 1, 1, tzinfo=None)
* dt.max # -> dt(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).
* dt.year
* dt.month
* dt.day
* dt.hour
* dt.minute
* dt.second
* dt.microsecond
* dt.tzinfo
* dt.fold -> in [0, 1] -- overlapping hour at the end of DST

Operators:

* dt2 = dt1 + timedelta
* dt2 = dt1 - timedelta
* timedelta = dt1 - dt2
* dt1 < dt2

* dt.replace(year=self.year, month=self.month, day=self.day, hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, fold=0)
* dt.timetuple()  # -> time.struct_time((d.year, d.month, d.day, d.hour, d.minute, d.second, d.weekday(), yday, dst))

* dt.weekday()  # Monday 0 .. Sunday 6
* dt.isoweekday()  # Monday 1 .. Sunday 7
* dt.isocalendar()
* dt.isoformat(sep='T', timespec='auto')  # -> "YYYY-MM-DDTHH:MM:SS.ffffff"
* dt.__str__()  # -> dt.isoformat()
* dt.ctime()
* dt.strftime(format)
* dt.__format__(format)  # thus f"{dt1:%B %d, %Y}"



=== Date Formatting (per the C89 standard)

[width="100%"]
|===
| %a | Weekday abbr                        | Mon..Sun
| %A | Weekday full name                   | Monday..Sunday
| %w | Weekday as a decimal                | 0..6
| %d | Day of month                        | 01..31
| %b | Month abbr                          | Jan..Dec
| %B | Month full name                     | January..December
| %m | Month                               | 01..12
| %y | 2-digit Year                        | 00..99
| %Y | 4-digit Year                        | 0001..9999
| %H | Military Hour                       | 00..23
| %I | Civilian Hour                       | 01..12
| %p | AM/PM                               | AM, PM
| %M | Minute                              | 00..59
| %S | Second                              | 00..59
| %f | Microsecond                         | 000000..999999
| %z | UTC offset                          | (empty), +0000, -0400, +1030, +063415, -030712.345216
| %Z | Time zone name                      | (empty), UTC, EST, CST
| %j | Day of the year                     | 001..366
| %U | Week of the year Sunday based       | 00..53
| %W | Week of the year Monday based       | 00..53
| %c | Locale’s appropriate representation | Tue Aug 16 21:30:00 1988
| %x | Locale’s appropriate representation | 08/16/1988
| %X | Locale’s appropriate representation | 21:30:00
| %% | Percent sign                        | %
|===

Additional Directives:

[width="100%"]
|===
| %G | ISO 8601 year that contains the greater part of the ISO week (%V) | 0001..9999
| %u | ISO 8601 weekday where 1 is Monday                                | 1..7
| %V | ISO 8601 week Monday based where Week 01 contains Jan 4.          | 01..53
|===



[[deprecation]]
=== Deprecation

https://github.com/tantale/deprecated[]

----
# pip install deprecated
from deprecated import deprecated

@deprecated(reason="Just use Path(filename).to_uri()")
----



[[dictionaries]]
== Dictionaries

Dict.`update`() is the counterpart of List.`extend`().

* `class dict(**kwarg)`
* `class dict(mapping, **kwarg)`
* `class dict(iterable, **kwarg)`
* `list(d)` -- A list of all the keys used in the dictionary.
* `len(d)` -- The number of items in the dictionary.
* `d[key]` -- Raises a KeyError if key is not in the map and no __missing__ method.
* `d[key] = value`
* `del d[key]` -- Raises a KeyError if key is not in the map.
* `key in d`
* `key not in d`
* `iter(d)` -- An iterator over the keys. Shortcut for iter(d.keys()).
* `clear()`
* `copy()` -- A shallow copy.
* `get(key[, default])` -- never raises a KeyError.
* `items()` A new view (dynamic) of the dictionary’s items ((key, value) pairs).
* `keys()` A new view (dynamic) of the dictionary’s keys.
* `pop(key[, default])` -- If default is not given and key is not in the dictionary, a KeyError is raised.
* `popitem()` -- Remove and return a (key, value) pair from the dictionary. Pairs are returned in LIFO order.
* `reversed(d)` - A reverse iterator over the keys. Shortcut for reversed(d.keys()).
* `setdefault(key[, default])` -- If key is in the dictionary, return its value. If not, add it.
* `update([other])` -- Update the dictionary with the key/value pairs from other.
* `values()` -- A new view (dynamic) of the dictionary’s values.

* Merging dictionaries (Python 3.5+): `merged = { **dict1, **dict2 }`

* repeat: `two_by_two_array = [[0]*2]*2`
* Zipper: `list_of_tuples = zip(list1, list2, list3)`
* `for key, value in d.items():`






[[dunder-methods]]
== Dunder Methods

=== Basic Customizations

`__new__`(self) return a new object (an instance of that class). It is called before ``__init__`` method.
`__init__`(self) is called when the object is initialized. It is the constructor of a class.
`__del__`(self) for del() function. Called when the object is to be destroyed. Can be used to commit unsaved data or close connections.
`__repr__`(self) for repr() function. It returns a string to print the object. Intended for developers to debug. Must be implemented in any class.
`__str__`(self) for str() function. Return a string to print the object. Intended for users to see a pretty and useful output. If not implemented, `__repr__` will be used as a fallback.
`__bytes__`(self) for bytes() function. Return a byte object which is the byte string representation of the object.
`__format__`(self) for format() function. Evaluate formatted string literals like % for percentage format and ‘b’ for binary.
`__lt__`(self, anotherObj) for < operator.
`__le__`(self, anotherObj) for <= operator.
`__eq__`(self, anotherObj) for == operator.
`__ne__`(self, anotherObj) for != operator.
`__gt__`(self, anotherObj)for > operator.
`__ge__`(self, anotherObj)for >= operator.

=== Arithmetic Operators

`__add__`(self, anotherObj) for + operator.
`__sub__`(self, anotherObj) for – operation on object.
`__mul__`(self, anotherObj) for * operation on object.
`__matmul__`(self, anotherObj) for @ operator (numpy matrix multiplication).
`__truediv__`(self, anotherObj) for simple / division operation on object.
`__floordiv__`(self, anotherObj) for // floor division operation on object.

=== Type Conversion

`__abs__`(self) make support for abs() function. Return absolute value.
`__int__`(self) support for int() function. Returns the integer value of the object.
`__float__`(self) for float() function support. Returns float equivalent of the object.
`__complex__`(self) for complex() function support. Return complex value representation of the object.
`__round__`(self, nDigits) for round() function. Round off float type to 2 digits and return it.
`__trunc__`(self) for trunc() function of math module. Returns the real value of the object.
`__ceil__`(self) for ceil() function of math module. The ceil function Return ceiling value of the object.
`__floor__`(self) for floor() function of math module. Return floor value of the object.

=== Emulating Container Types

`__len__`(self) for len() function. Returns the total number in any container.
`__getitem__`(self, key) to support indexing. Like container[index]. Calls `container.__getitem(key)` explicitly.
`__setitem__`(self, key, value) makes item mutable (items can be changed by index), like container[index] = otherElement.
`__delitem__`(self, key) for del() function. Delete the value at the index key.
`__iter__`(self) returns an iterator when required that iterates all values in the container.






[[encoding-encryption]]
== Encoding/Encryption

Python Modules:

* base64 -- RFC 4648: Base16, Base32, Base64 Data Encodings; Base85 and Ascii85
* binascii -- Tools for converting between binary and various ASCII-encoded binary representations.
* codecs -- Encode and decode data and streams.
* encodings -- TBD
* hashlib -- Secure hash and message digest algorithms.
* hmac -- Keyed-Hashing for Message Authentication (HMAC) implementation
* marshal -- Convert Python objects to streams of bytes and back (with different constraints).







[[email]]
== Email

Python Modules:

* email -- Package supporting the parsing, manipulating, and generating email messages.
* imaplib -- IMAP4 protocol client (requires sockets).
* mailbox -- Manipulate mailboxes in various formats
* poplib -- POP3 protocol client (requires sockets).
* smtplib -- SMTP protocol client (requires sockets).





[[error-handling]]
== Error Handling

Python Modules:

* *errno* -- Standard errno system symbols.
* *warnings* -- Issue warning messages and control their disposition.

=== Built-In Error and Warning Exceptions

These all descend from `Exception` (which inherits from `BaseException`).
User-defined errors should descend from `Exception`.
User-defined warnings should descend from `UserWarning`.

* StopIteration, StopAsyncIteration
* ArithmeticError => FloatingPointError, OverflowError, ZeroDivisionError
* AssertionError
* AttributeError
* BufferError
* EOFError
* ImportError => ModuleNotFoundError
* LookupError => IndexError, KeyError
* MemoryError
* NameError => UnboundLocalError
* OSError =>
** BlockingIOError
** ChildProcessError
** ConnectionError => BrokenPipeError, ConnectionAbortedError, ConnectionRefusedError, ConnectionResetError
** FileExistsError
** FileNotFoundError
** InterruptedError
** IsADirectoryError
** NotADirectoryError
** PermissionError
** ProcessLookupError
** TimeoutError
* ReferenceError
* RuntimeError => NotImplementedError, RecursionError
* SyntaxError => IndentationError => TabError
* SystemError
* TypeError
* ValueError => UnicodeError = > UnicodeDecodeError, UnicodeEncodeError, UnicodeTranslateError
* Warning =>
* ** *UserWarning* -- _base class for user-defined warnings._
** RuntimeWarning
** FutureWarning, DeprecationWarning, PendingDeprecationWarning
** SyntaxWarning, ImportWarning
** UnicodeWarning
** BytesWarning
** EncodingWarning
** ResourceWarning

=== Built-In Exception-like SIGNALs

These all inherit directly from BaseException.

* SystemExit
* KeyboardInterrupt
* GeneratorExit











[[files]]
== Files

Python Modules:

* *csv* -- Write and read tabular data to and from delimited files.
* dbm -- Interfaces to various Unix "database" formats.
* *filecmp* -- Compare files efficiently.
* fileinput -- Loop over standard input or a list of files.
* fnmatch -- Unix shell style filename pattern matching.
* glob -- Unix shell style pathname pattern expansion.
* linecache -- Provides random access to individual lines from text files.
* mimetypes -- Mapping of filename extensions to MIME types.
* *mmap* -- Interface to memory-mapped files for Unix and Windows.
* pathlib -- Object-oriented filesystem paths
* shutil -- High-level file operations, including copying.
* *tempfile* -- Generate temporary files and directories.


=== High-Level Directory and File Operations

In the following, src and dst can be a str or Path.

* shutil.copyfileobj(fsrc, fdst[, length])
* shutil.copyfile(src, dst, `*`, follow_symlinks=True)
* shutil.copymode(src, dst, `*`, follow_symlinks=True) -- Copy the permission bits
* shutil.copystat(src, dst, `*`, follow_symlinks=True) -- Copy the permission bits, timestamps, and flags
* shutil.copy(src, dst, `*`, follow_symlinks=True) -- dst can be a directory
* shutil.copy2(src, dst, `*`, follow_symlinks=True) -- attempts to preserve file metadata
* shutil.ignore_patterns(``*``patterns) -- creates a function that can be passed in to copytree()
* shutil.copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False, dirs_exist_ok=False) -- Recursively copy an entire directory tree rooted at src to a directory named dst and return the destination directory.
* shutil.rmtree(path, ignore_errors=False, onerror=None) -- Delete a directory tree
* shutil.move(src, dst, copy_function=copy2) = Recursively move a file or directory
* shutil.disk_usage(path) -- disk usage statistics about the given path -> named tuple (total, used, free)
* shutil.chown(path, user=None, group=None)
* shutil.which(cmd, mode=os.F_OK | os.X_OK, path=None) -- executable which would be run




[[files-archives]]
== File Archive/Compression

* shutil.make_archive(base_name, format[, root_dir[, base_dir[, verbose[, dry_run[, owner[, group[, logger]]]]]]]) -- Create an archive (zip, tar...) -> name: str.
* shutil.get_archive_formats() -> List of tuples (name, description)
* shutil.register_archive_format(name, function[, extra_args[, description]])
* shutil.unregister_archive_format(name)
* shutil.unpack_archive(filename[, extract_dir[, format]])
* shutil.register_unpack_format(name, extensions, function[, extra_args[, description]])
* shutil.unregister_unpack_format(name)
* shutil.get_unpack_formats()

Python Modules:

* bz2 -- Interfaces for bzip2 compression and decompression.
* gzip -- Interfaces for gzip compression and decompression using file objects.
* lzma -- A Python wrapper for the liblzma compression library.
* tarfile -- Read and write tar-format archive files.
* zipfile -- Read and write ZIP-format archive files.
* zipimport -- Support for importing Python modules from ZIP archives.
* zlib -- Low-level interface to compression and decompression routines compatible with gzip.



[[graphics]]
== Graphics

Python Modules:

* colorsys -- Conversion functions between RGB and other color systems.


=== Images

----
pip3 install Pillow
from PIL import Image
im = Image.open("kittens.jpg")
im.show()
(im.format, im.size, im.mode) -> JPEG (1920, 1357) RGB
----

=== Emoji

* `pip3 install emoji` -- https://pypi.org/project/emoji/





[[gui]]
== GUI

See also the link::KIVY_CHEAT.adoc[Kivy Cheat Sheet]

Python Modules:

* *webbrowser* -- Easy-to-use controller for web browsers.
* tkinter -- Interface to Tcl/Tk for graphical user interfaces
* turtle -- An educational framework for simple graphics applications
* turtledemo -- A viewer for example turtle scripts




[[iterators]]
== Iterators

`import itertools`

* `iterator = itertools.accumulate(list1, list2)` -- runnning totals
* `iterator = itertools.chain(list1, list2)` -- logical List.extend()
* `iterator = itertools.compress(list1, list2)` -- list1[i] if list2[i]





[[lint]]
== Lint

* For imports that appear to be unused but actually are, add `# noqa: F401` to the end of the line.

Flake8 Error Codes:

* E1 -- *Indentation*
* E101 -- indentation contains mixed spaces and tabs
* E111 -- indentation is not a multiple of four
* E112 -- expected an indented block
* E113 -- unexpected indentation
* E114 -- indentation is not a multiple of four (comment)
* E115 -- expected an indented block (comment)
* E116 -- unexpected indentation (comment)
* E117 -- over-indented
* E121 -- continuation line under-indented for hanging indent UNOFFICIAL NOQA-ABLE
* E122 -- continuation line missing indentation or outdented NOQA-ABLE
* E123 -- closing bracket does not match indentation of opening bracket’s line UNOFFICIAL
* E124 -- closing bracket does not match visual indentation NOQA-ABLE
* E125 -- continuation line with same indent as next logical line NOQA-ABLE
* E126 -- continuation line over-indented for hanging indent UNOFFICIAL NOQA-ABLE
* E127 -- continuation line over-indented for visual indent NOQA-ABLE
* E128 -- continuation line under-indented for visual indent NOQA-ABLE
* E129 -- visually indented line with same indent as next logical line NOQA-ABLE
* E131 -- continuation line unaligned for hanging indent NOQA-ABLE
* E133 -- closing bracket is missing indentation UNOFFICIAL
* E2 -- *Whitespace*
* E201 -- whitespace after ‘(’
* E202 -- whitespace before ‘)’
* E203 -- whitespace before ‘,’, ‘;’, or ‘:’
* E211 -- whitespace before ‘(’
* E221 -- multiple spaces before operator
* E222 -- multiple spaces after operator
* E223 -- tab before operator
* E224 -- tab after operator
* E225 -- missing whitespace around operator
* E226 -- missing whitespace around arithmetic operator UNOFFICIAL
* E227 -- missing whitespace around bitwise or shift operator
* E228 -- missing whitespace around modulo operator
* E231 -- missing whitespace after ‘,’, ‘;’, or ‘:’
* E241 -- multiple spaces after ‘,’ UNOFFICIAL
* E242 -- tab after ‘,’ UNOFFICIAL
* E251 -- unexpected spaces around keyword / parameter equals
* E261 -- at least two spaces before inline comment
* E262 -- inline comment should start with ‘# ‘
* E265 -- block comment should start with ‘# ‘
* E266 -- too many leading ‘#’ for block comment
* E271 -- multiple spaces after keyword
* E272 -- multiple spaces before keyword
* E273 -- tab after keyword
* E274 -- tab before keyword
* E275 -- missing whitespace after keyword
* E3 -- *Blank line*
* E301 -- expected 1 blank line, found 0
* E302 -- expected 2 blank lines, found 0
* E303 -- too many blank lines (3)
* E304 -- blank lines found after function decorator
* E305 -- expected 2 blank lines after end of function or class
* E306 -- expected 1 blank line before a nested definition
* E4 -- *Import*
* E401 -- multiple imports on one line
* E402 -- module level import not at top of file
* E5 -- *Line length*
* E501 -- line too long (82 > 79 characters) NOQA-ABLE
* E502 -- the backslash is redundant between brackets
* E7 -- *Statement*
* E701 -- multiple statements on one line (colon)
* E702 -- multiple statements on one line (semicolon)
* E703 -- statement ends with a semicolon
* E704 -- multiple statements on one line (def) UNOFFICIAL
* E711 -- comparison to None should be ‘if cond is None:’ NOQA-ABLE
* E712 -- comparison to True should be ‘if cond is True:’ or ‘if cond:’ NOQA-ABLE
* E713 -- test for membership should be ‘not in’
* E714 -- test for object identity should be ‘is not’
* E721 -- do not compare types, use ‘isinstance()’ NOQA-ABLE
* E722 -- do not use bare except, specify exception instead
* E731 -- do not assign a lambda expression, use a def
* E741 -- do not use variables named ‘l’, ‘O’, or ‘I’
* E742 -- do not define classes named ‘l’, ‘O’, or ‘I’
* E743 -- do not define functions named ‘l’, ‘O’, or ‘I’
* E9 -- *Runtime*
* E901 -- SyntaxError or IndentationError
* E902 -- IOError
* F4 -- *Import*
* F401 -- module imported but unused
* F402 -- import module from line N shadowed by loop variable
* F403 -- ‘from module import ...’ used; unable to detect undefined names
* F404 -- future import(s) name after other statements
* F405 -- name may be undefined, or defined from star imports: module
* F406 -- ‘from module import ...’ only allowed at module level
* F407 -- an undefined __future__ feature name was imported
* F5 -- *Format*
* F501 -- invalid % format literal
* F502 -- % format expected mapping but got sequence
* F503 -- % format expected sequence but got mapping
* F504 -- % format unused named arguments
* F505 -- % format missing named arguments
* F506 -- % format mixed positional and named arguments
* F507 -- % format mismatch of placeholder and argument count
* F508 -- % format with * specifier requires a sequence
* F509 -- % format with unsupported format character
* F521 -- .format(...) invalid format string
* F522 -- .format(...) unused named arguments
* F523 -- .format(...) unused positional arguments
* F524 -- .format(...) missing argument
* F525 -- .format(...) mixing automatic and manual numbering
* F541 -- f-string without any placeholders
* F6 -- *Expression*
* F601 -- dictionary key name repeated with different values
* F602 -- dictionary key variable name repeated with different values
* F621 -- too many expressions in an assignment with star-unpacking
* F622 -- two or more starred expressions in an assignment (a, ``*``b, ``*``c = d)
* F631 -- assertion test is a tuple, which is always True
* F632 -- use ==/!= to compare str, bytes, and int literals
* F633 -- use of >> is invalid with print function
* F634 -- if test is a tuple, which is always True
* F7 -- *Logic Flow*
* F701 -- a break statement outside of a while or for loop
* F702 -- a continue statement outside of a while or for loop
* F703 -- a continue statement in a finally block in a loop
* F704 -- a yield or yield from statement outside of a function
* F706 -- a return statement outside of a function/method
* F707 -- an except: block as not the last exception handler
* F721 -- syntax error in doctest
* F722 -- syntax error in forward annotation
* F723 -- syntax error in type comment
* F8 -- *Variable*
* F811 -- redefinition of unused name from line N
* F821 -- undefined name name
* F822 -- undefined name name in __all__
* F823 -- local variable name … referenced before assignment
* F831 -- duplicate argument name in function definition
* F841 -- local variable name is assigned to but never used
* F9 -- *Error Handling*
* F901 -- raise NotImplemented should be raise NotImplementedError
* W1 -- *Indentation warning*
* W191 -- indentation contains tabs
* W2 -- *Whitespace warning*
* W291 -- trailing whitespace
* W292 -- no newline at end of file
* W293 -- blank line contains whitespace
* W3 -- *Blank line warning*
* W391 -- blank line at end of file
* W5 -- *Line break warning*
* W503 -- line break before binary operator UNOFFICIAL
* W504 -- line break after binary operator UNOFFICIAL
* W505 -- doc line too long (82 > 79 characters) UNOFFICIAL NOQA-ABLE
* W6 -- *Deprecation warning*
* W605 -- invalid escape sequence ‘x’
* W606 -- ‘async’ and ‘await’ are reserved keywords starting with Python 3.7*



[[lists]]
== Lists

* List Comprehension: `[ expression for item in list if conditional ]`
* List Comprehension via Generator: `g = (item for item in "hello")` then `print(list(g))`
* Reversing strings and lists: `revstring = "abcdefg"[::-1]`
* Map: `map(function, something_iterable)`
* Unique elements: `set(mylist)`
* Most frequently occurring value: `max(set(test), key = test.count)`
* Counting occurrences: `from collections import Counter`
* List.append(single item)
* List.extend(another list)
* Size: `len(container)`
* list.clear()
* list.remove(value)
* list.pop(index) or del list[index]
* list.pop() -- last item




[[logic-flow]]
== Logic Flow

*Ternary* syntax: var = expression if expression else expression

Else-if syntax: *elif*

For/While ... *Else*: The else clause is suppressed if we explicitly break out of the loop

Switch logic (as of 3.10):
----
match value:
    case condition:
        action(s)
----




[[media]]
== Media

Python Modules:

* wave -- Provide an interface to the WAV sound format.





[[networking-internet]]
== Networking/Internet

Python Modules:

* ftplib -- FTP protocol client (requires sockets).
* http -- HTTP status codes and messages
* ipaddress -- IPv4/IPv6 manipulation library.
* socket -- Low-level networking interface.
* socketserver -- A framework for network servers.
* ssl -- TLS/SSL wrapper for socket objects
* urllib -- TBD


=== Quickly Create a Web Server

You can quickly start a web server, serving the contents of the current directory:
`python3 -m http.server`


=== Beautiful Soup

* Details -- : https://beautiful-soup-4.readthedocs.io/en/latest/[]




[[numbers]]
== Numbers/Math

* *Integer division* operator: `//`
* *Modulo* operator: `%`
* *Chaining comparison operators*: `if 5 < x < 15:` (But, avoid using.)

Python Modules:

* cmath -- Mathematical functions for complex numbers.
* decimal -- Implementation of the General Decimal Arithmetic Specification.
* fractions -- Rational numbers.
* math -- Mathematical functions (sin() etc.).
* numbers -- Numeric abstract base classes (Complex, Real, Integral, etc.).
* operator -- Functions corresponding to the standard operators.
* random -- Generate pseudo-random numbers with various common distributions.
* statistics -- Mathematical statistics functions




[[operating-system]]
== Operating System

Python Modules:

* curses -- (Unix) An interface to the curses library, providing portable terminal handling.
* fcntl -- (Unix)  The fcntl() and ioctl() system calls.
* grp -- (Unix)  The group database (getgrnam() and friends).
* msvcrt -- (Windows)  Miscellaneous useful routines from the MS VC++ runtime.
* os -- Miscellaneous operating system interfaces.
* platform -- Retrieves as much platform identifying data as possible.
* posix -- (Unix)  The most common POSIX system calls (normally used via module os).
* pty -- (Unix)  Pseudo-Terminal Handling for Unix.
* pwd -- (Unix)  The password database (getpwnam() and friends).
* readline -- (Unix) GNU readline support for Python.
* resource -- (Unix) An interface to provide resource usage information on the current process.
* stat -- Utilities for interpreting the results of os.stat(), os.lstat() and os.fstat().
* sys -- Access system-specific parameters and functions.
* syslog -- (Unix) An interface to the Unix syslog library routines.
* termios -- (Unix)  POSIX style tty control.
* tty -- (Unix)  Utility functions that perform common terminal control operations.
* winreg -- (Windows)  Routines and objects for manipulating the Windows registry.
* winsound -- (Windows)  Access to the sound-playing machinery for Windows.



[[pathlib]]
== PathLib

* p / str -- join operator
* p / p -- join operator
* str(p)

=== Pure pathlib.Path Properties

* p.parts -- tuple of the path broken down `Path('/usr/bin/python3').parts` -> `('/', 'usr', 'bin', 'python3')`
* p.drive -- string representing the drive letter or name, if any
* p.root -- string representing the (local or global) root, if any
* p.anchor -- concatenation of the drive and root
* p.parents -- immutable sequence providing access to the logical ancestors of the path
* p.parent -- logical parent of the path
* p.name -- string representing the final path component, excluding the drive and root, if any
* p.suffix -- file extension of the final component, if any:
* p.suffixes -- `Path("my/library.tar.gz").suffixes` -> `["tar","gz"]`
* p.stem -- final path component, without its suffix

=== Pure pathlib.Path Methods

* p.as_posix() -- string representation of the path with forward slashes (/)
* p.as_uri() -- `Path('/etc/passwd')` -> `file:///etc/passwd`
* p.is_absolute() -- `Path('/a/b').is_absolute()` -> `True`
* p.is_reserved() -- `PureWindowsPath('nul').is_reserved()` -> `True`
* p.joinpath(``*``other) -- same as the join operator
* p.match(pattern) -- glob-style pattern
* p.relative_to(``*``other) -- ValueError raised if impossible
* p.with_name(name) -- new path with the name changed. ValueError raised if original path has no name. `Path('c:/Downloads/pathlib.tar.gz').with_name('setup.py')` -> `Path('c:/Downloads/setup.py')`

=== Concrete Path Methods

* Path.cwd() -- the current directory
* Path.home() -- the user's home directory
* p.stat() -- os.stat_result object
* p.chmod(mode) -- Change the file mode and permissions
* p.exists() -- file or directory
* p.expanduser() -- new path with expanded ~ and ~user constructs
* p.glob(pattern) -- yields all matching files (of any kind) -> List[Path]
* p.group() -- name of the group owning the file
* p.is_dir() -- True if the path points to a directory (or symlink to one)
* p.is_file() -- True if the path points to a regular file (or symlink to one)
* p.is_mount() True if the path is a mount point
* p.is_symlink()
* p.is_socket()
* p.is_fifo()
* p.is_block_device()
* p.is_char_device()
* p.iterdir() -- When the path points to a directory, yields path objects of the contents (random order)
* p.lchmod(mode) -- of the symbolic link itself
* p.lstat() -- of the symbolic link itself
* p.mkdir(mode=0o777, parents=False, exist_ok=False)
* p.open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)
* p.owner()
* p.read_bytes()
* p.read_text(encoding=None, errors=None)
* p.rename(target) -- rename unless target exists
* p.remove -- (no such method) Use unlink() to remove a file.
* p.replace(target) -- rename regardless (clobber any existing target)
* p.resolve(strict=False) -- Make the path absolute, resolving any symlinks. A new path object is returned
* p.rglob(pattern) -- glob() with `**/` prefix assumed (recursive)
* p.rmdir() -- the directory must be empty
* p.samefile(other_path) -- True if points to the same file
* p.symlink_to(target, target_is_directory=False)
* p.unlink(missing_ok=False) -- remove a file OR a symlink
* p.link_to(target) -- create a hard link pointing to a path named target
* p.write_bytes(data)
* p.write_text(data, encoding=None, errors=None)

[width="100%",cols="",options="header"]
|===
| os and os.path            | pathlib
| os.path.abspath()         | Path.resolve()
| os.chmod()                | Path.chmod()
| os.mkdir()                | Path.mkdir()
| os.rename()               | Path.rename()
| os.replace()              | Path.replace()
| os.rmdir()                | Path.rmdir()
| os.remove(file)           |
| os.removedir()            |
| os.removedirs()           | -- | removes leaf directory and all now-empty parent directories
| os.remove(), os.unlink()  | Path.unlink()
| os.getcwd()               | Path.cwd()
| os.path.exists()          | Path.exists()
| os.path.expanduser()      | Path.expanduser() and Path.home()
| os.listdir()              | Path.iterdir()
| os.path.isdir()           | Path.is_dir()
| os.path.isfile()          | Path.is_file()
| os.path.islink()          | Path.is_symlink()
| os.link()                 | Path.link_to()
| os.symlink()              | Path.symlink_to()
| os.stat()                 | Path.stat(), Path.owner(), Path.group()
| os.path.isabs()           | PurePath.is_absolute()
| os.path.join()            | PurePath.joinpath()
| os.path.basename()        | PurePath.name
| os.path.dirname()         | PurePath.parent
| os.path.samefile()        | Path.samefile()
| os.path.splitext()        | PurePath.suffix
|===

NOTE: Although os.path.relpath() and PurePath.relative_to() have some overlapping use-cases, their semantics differ enough to warrant not considering them equivalent.



[[pip]]
== Install PIP (Windows)

How to manually install PIP if it was not originally included (e.g. the version of Python 3.8.18 that is distributed within LibreOffice 7.5):

TIP: In Windows Explorer, Shift+RightClick offers "Open PowerShell window here"

IMPORTANT: Be sure to run PowerShell as Administrator

. Open PowerShell and navigate to the folder where Python is installed: `cd "C:\Program Files\LibreOffice\program"`
. Run this command to install pip:
----
(Invoke-WebRequest -Uri https://bootstrap.pypa.io/get-pip.py -UseBasicParsing).Content | .\python.exe -
.\python.exe -m pip --version
----
NOTE: You may get a warning that the pip install location is not on that path. This warning can be ignored.



[[pip-e]]
== PIP Install Editable (-e)

When `PIP install -e .` complains that it can't find a module/package, it might actually be fine.
If VSCode test explorer can't find any tests in your editable module, it might be because you need to reconfigure pytest.
(Command Palette: "Python: Configure Tests".)



[[poetry]]
== poetry (Installing on Windows)

Poetry is a tool that facilitates creating a Python virtual environment based on the project dependencies.
You can declare the libraries your project depends on, and Poetry will install and update them for you.
Project dependencies are recorded in the `pyproject.toml` file that specifies required packages, scripts, plugins, and URLs.

Installing poetry via PowerShell:

----
(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py -
$Env:Path += ";C:\Users\CRaig Jones\AppData\Roaming\Python\Scripts"; setx PATH "$Env:Path"
poetry --version
poetry config virtualenvs.in-project true
----

[[pytest]]
== pytest

=== Running as main()

[source,python]
----
import pytest

def main():
    pytest.main([__file__])

if __name__ == '__main__':
    main()
----

=== Testing *expected exceptions*:

[source,python]
----
import pytest

with pytest.raises(ValueError) as e_info:
	pass
assert 'my message substring' in str(e_info)
----

=== Testing *stdout* and *stderr* via the `capsys` fixture:

[source,python]
----
# (capsys does not need to be imported -- not sure why)
from gwpycore import logger_for_testing, grab_captured_err_text, stderr_start_marker, stderr_end_marker

def test_GWError(capsys):
    log = logger_for_testing()
    stderr_start_marker()
    log.exception(GWError("exception"))
    log.exception(GWError("log as info", loglevel=INFO))
    stderr_end_marker()
    captured = capsys.readouterr()
    assert captured.out == ""
    err_txt = grab_captured_err_text(captured)
    assert err_txt == "[ERROR  ] exception\n[INFO   ] log as info\n"
----

It's important that every test uses a different logger name (which `logger_for_testing()` does via the `random_token()` function); otherwise, you'll get errors trying to write to a closed file between one test to another.



[[python-internals]]
== Python Internals

Python Modules:

* `_compile` -- Generate byte-code files from Python source files.
* atexit -- Register and execute cleanup functions.
* builtins -- The module that provides the built-in namespace.
* codeop -- Compile (possibly incomplete) Python code.
* compileall -- Tools for byte-compiling all Python source files in a directory tree.
* contextlib -- Utilities for with-statement contexts.
* copy -- Shallow and deep copy operations.
* copyreg -- Register pickle support functions.
* ctypes -- A foreign function library for Python.
* functools -- Higher-order functions and operations on callable objects.
* gc -- Interface to the cycle-detecting garbage collector.
* importlib -- The implementation of the import machinery.
* itertools -- Functions creating iterators for efficient looping.
* keyword -- Test whether a string is a keyword in Python.
* modulefinder -- Find modules used by a script.
* pickle -- Convert Python objects to streams of bytes and back.
* pickletools -- Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions.
* pkgutil -- Utilities for the import system.
* pprint -- Data pretty printer.
* shlex -- Simple lexical analysis for Unix shell-like languages.
* symtable -- Interface to the compiler's internal symbol tables.
* sysconfig -- Python's configuration information
* token -- Constants representing terminal nodes of the parse tree.
* tokenize -- Lexical scanner for Python source code.
* weakref -- Support for weak references and weak dictionaries.






[[python-tooling]]
== Python Tooling

Python Modules:

* bdb -- Debugger framework.
* code -- Facilities to implement read-eval-print loops.
* cProfile -- TBD
* dis -- Disassembler for Python bytecode.
* distutils -- Support for building and installing Python modules into an existing Python installation.
* ensurepip -- Bootstrapping the "pip" installer into an existing Python installation or virtual environment.
* faulthandler -- Dump the Python traceback.
* inspect -- Extract information and source code from live objects.
* lib2to3 -- The 2to3 library
* logging -- Flexible event logging system for applications.
* pdb -- The Python debugger for interactive interpreters.
* profile -- Python source profiler.
* pstats -- Statistics object for use with the profiler.
* pyclbr -- Supports information extraction for a Python module browser.
* pydoc -- Documentation generator and online help system.
* reprlib -- Alternate repr() implementation with size limits.
* runpy -- Locate and run Python modules without importing them first.
* tabnanny -- Tool for detecting white space related problems in Python source files in a directory tree.
* *timeit* -- Measure the execution time of small code snippets.
* tomllib -- Parse TOML files.
* trace -- Trace or track Python statement execution.
* traceback -- Print or retrieve a stack traceback.
* tracemalloc -- Trace memory allocations.
* venv -- Creation of virtual environments.
* zipapp -- Manage executable Python zip archives



[[regex]]
== RegEx

Details: https://docs.python.org/3/library/re.html[]


* re.*compile*(pattern, flags=0)
* re.*search*(pattern, string, flags=0) -- Any one match
* re.*match*(pattern, string, flags=0) -- Matches at the beginning of string only (regardless of any MULTILINE flag)
* re.*fullmatch*(pattern, string, flags=0) -- Matches the whole string only
* re.*split*(pattern, string, maxsplit=0, flags=0) -- Split using pattern as delimiters. List will include paren captures within the delimiter.
* re.*findall*(pattern, string, flags=0) -- Returns all non-overlapping matches as a list (strings or tuples).
* re.*finditer*(pattern, string, flags=0)
* re.*sub*(pattern, repl, string, count=0, flags=0)
* re.*subn*(pattern, repl, string, count=0, flags=0) -- Same as sub(), but returns a tuple (new_string, number_of_subs_made).
* re.*escape*(pattern) -- converts a string to a pattern
* re.*purge*() -- Clears the regular expression cache.
* Match.*expand*(template) -- do the substitution (with backrefs).
* Match.*group*([group1, ...]), m[group] -- Returns one or more subgroups of the match (string or tuple).
* Match.*groups*(default=None) -- Returns all subgroups as a tuple.
* Match.*groupdict*(default=None) -- Returns a named subgroups
* Match.*start*([group]), Match.end([group]) -- Return the indices of the matched string
* Match.*span*([group]) -- Returns a tuple: (m.start(group), m.end(group)).
* Match.*pos* -- Where the RE engine started looking for a match.
* Match.*endpos* -- Where the RE engine stopped looking for a match.
* Match.*lastindex* -- The integer index of the last matched capturing group, or None if no group was matched at all. For example, the expressions (a)b, ((a)(b)), and ((ab)) will have lastindex == 1 if applied to the string 'ab', while the expression (a)(b) will have lastindex == 2, if applied to the same string.
* Match.*lastgroup* -- The name of the last matched capturing group, or None if the group didn’t have a name, or if no group was matched at all.
* Match.*re* -- The regular expression object whose match() or search() method produced this match instance.
* Match.*string* -- The string passed to match() or search().


=== Replacement Backref Modifiers

----
  \l : first character to lower case
  \u : first character to upper case
  \L : start of lower case conversion
  \U : start of upper case conversion
  \E : end lower/upper case conversion
----

=== Flags

----
re.I, re.IGNORECASE, (?i) : Performs case-insensitive matching.
re.M, re.MULTILINE, (?m)  : Caret and dollar match line-by-line.
re.S, re.DOTALL, (?s)     : '.' will match anything INCLUDING a newline.
re.A, re.ASCII, (?a)      : Disables full Unicode matching.
re.DEBUG                  : Displays debug information about compiled expression.
re.L, re.LOCALE, (?L)     : Makes case-insensitive matching dependent on the current locale.
re.X, re.VERBOSE, (?x)    : Allow comments and whitespace in expressions.
----



[[security]]
== Security

Python Modules:

* getpass -- Portable reading of passwords and retrieval of the userid.
* secrets -- Generate secure random numbers for managing secrets.







[[sets]]
== Sets

Set.add() is the counterpart to List.append().
Set.update() is the counterpart to List.extend().

* s.add(some_new_element)
* s.remove(element)
* s.update(other_set)
* s.union(other_set) (or the vertical bar operator)
* s.intersection(other_set) (or the ampersand operator)
* s.difference(other_set) (or the minus sign operator)
* s.symmetric_difference(other_set) (or the carret operator)
* s.isdisjoint(other_set)
* s.issubset() (or `<=`, or `<` for a proper subset)
* s.issuperset() (or `>=`, or `>` for a proper superset)
* len(s)
* element in s



[[sorting]]
== Sorting

* `lst.sort()` or `sorted(lst)`
* `lst.sort(reverse=True)` or `sorted(lst, reverse=True)`
* `lst.sort(key=lambda x: x[1])` or `sorted(lst, key=fn)`
* For case-insensitive, use `key=str.lower`







[[strings]]
== Strings/Text Processing/I18n/Unicode

Python Modules:

* ast -- Abstract Syntax Tree classes and manipulation.
* gettext -- Multilingual internationalization services.
* *html* -- Helpers for manipulating HTML.
* locale -- Internationalization services.
* re -- Regular expression operations.
* string -- Common string operations.
* stringprep -- String preparation, as per RFC 3453
* textwrap -- Text wrapping and filling
* unicodedata -- Access the Unicode Database.


=== String Functions

* * str.*capitalize*() -- copy of the string with its first character capitalized and the rest lowercased.
* * str.*casefold*() -- for caseless matching (slightly more agressive than lower())
* str.*center*/*ljust*/*rjust*(width[, fillchar])
* * str.*count*(sub[, start[, end]]) -- number of non-overlapping occurrences of substring sub in the range [start, end].
* str.*encode*(encoding="utf-8", errors="strict")
* str.*expandtabs*(tabsize=8)
* * str.*find*/*rfind*(sub[, start[, end]]) -- Only use to determine the position; otherwise use the `in` operator.
* str.*format*(``*``args, ``**``kwargs)
* str.*format_map*(mapping)
* * str.*index*/*rindex*(sub[, start[, end]]) -- Like find(), but raise ValueError when the substring is not found.
* * str.*isidentifier*() -- Also: Call keyword.iskeyword(str) to test if is a reserved identifier.
* str.*isalnum*()
* str.*isalpha*(), str.*isascii*(), str.*isdecimal*(), str.*isdigit*(), str.*islower*(), str.*isnumeric*(), str.*isprintable*(), str.*isspace*(), str.*istitle*(), str.*isupper*()
* str.*join*(iterable)
* * str.*lower*() -- see also *casefold*()
* * str.*partition*/*rpartition*(sep) -- Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings.
* * str.*replace*(old, new[, count]) -- a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. (For Regex replacements, use re.sub().)
* * str.*split*/*rsplit*(sep=None, maxsplit=-1) -- breaking the string at word boundaries (sep=None means split on runs of whitespace.)
* * str.*splitlines*([keepends]) -- breaking the string at line boundaries. (Use keepend=True to keep the EOL).
* str.*startswith*/*endswith*(prefix[, start[, end]])
* * str.*strip*/*lstrip*/*rstrip*([chars]) -- a copy of the string with the leading and trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped:
* * str.*swapcase*() -- a copy of the string with uppercase characters converted to lowercase and vice versa. Note that it is not necessarily true that s.swapcase().swapcase() == s.
* * str.*title*() -- a titlecased version of the string
* * str.*translate*(table) -- a copy of the string in which each character has been mapped through the given translation table. The table must be an object that implements indexing via __getitem__(), typically a mapping or sequence. When indexed by a Unicode ordinal (an integer), the table object can do any of the following: return a Unicode ordinal or a string, to map the character to one or more other characters; return None, to delete the character from the return string; or raise a LookupError exception, to map the character to itself. You can use str.maketrans() to create a translation map from character-to-character mappings in different formats.
* str.*upper*()
* * str.*zfill*(width) -- zero pad

=== String Constants

* string.*ascii_letters* == ascii_lowercase + ascii_uppercase
* * string.*ascii_lowercase* -- 'abcdefghijklmnopqrstuvwxyz'
* * string.*ascii_uppercase* -- 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
* string.*digits* == '0123456789'
* string.*hexdigits* == '0123456789abcdefABCDEF'
* string.*octdigits* == '01234567'
* string.*punctuation* == `!"#$%&'()*+,-./:;<=>?@[\]^_{|}~`  (plus back tic)
* string.*printable* == digits `+` ascii_letters `+` punctuation + whitespace.
* string.*whitespace* == space, tab, linefeed, return, formfeed, and vertical tab.

=== F-Strings

* f"{foo}" -- displays the value alone
* f"{foo = }" -- displays the expression followed by the value
* f"{foo:25}"  -- left align
* f"{foo:=>25}"  -- right align using a fill character of =
* f"{foo:``^``25}"  -- center align
* f"{foo!r}" -- for using `__repl__` instead of `__str__`
* f"{foo:s}" -- formatted as a string
* f"{foo:d}" -- formatted as a decimal integer (with commas)
* f"{foo:n}" -- formatted as a number (per locale)
* f"{foo:e}" -- formatted as scientific notation
* f"{foo:f}" -- formatted as fixed point
* f"{foo:20f}" -- formatted as fixed point within a 20-char field
* f"{foo:%}" -- formatted as fixed * 100
* f"{variable:+,.2f}") -- formatted with two decimal places, a forced plus-sign, and commas


=== String Misc.

TODO: Multi-Line Strings vs. """





[[testing]]
== Testing

Python Modules:

* doctest -- Test pieces of code within docstrings.
* test -- Regression tests package containing the testing suite for Python.
* unittest -- Unit testing framework for Python.
* <<pytest,pytest>> -- Simplified using testing using Python native assert statements



[[tuples]]
== Tuples

`Color = namedtuple("Color", "red green blue", defaults=[0,0,0])`

color = Color.make([255,255,255])

* Unpacking: a, b, c = (1,2,3)



[[types]]
== Types/Classes

Python Modules:

* types -- Names for built-in types.
* typing -- Support for type hints (see :pep:`484`).
* abc -- Abstract base classes according to :pep:`3119`.
* dataclasses -- Generate special methods on user-defined classes.

----
isinstance(object, classinfo)
type([]) is list
type({}) is dict
type('') is str
type(0) is int
----








[[other]]
== OTHER (TO IDENTIFY/SORT)

Python Modules:

* *contextvars?* -- Context Variables
* *difflib?* -- Helpers for computing differences between objects.
* *sched?* -- General purpose event scheduler.
* idlelib -- Implementation package for the IDLE shell/editor.
* io -- Core tools for working with streams.
* netrc -- Loading of .netrc files.
* quopri -- Encode and decode files using the MIME quoted-printable encoding.
* rlcompleter -- Python identifier completion, suitable for the GNU readline library.
* site -- Module responsible for site-specific configuration.
* uuid -- UUID objects (universally unique identifiers) according to RFC 4122
* wsgiref -- WSGI Utilities and Reference Implementation.



