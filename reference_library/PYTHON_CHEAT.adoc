= A Python Cheat Sheet
polyglot-jones
v0.01, 9/14/2020

:toc:
:toc-placement!:

toc::[]

== Quick Start

=== Sublime Plugin

See link:SUBLIME_PLUGIN_CHEAT.adoc[]

=== Stand-Alone Script

=== Any Larger Project (GUI, CLI, library)

In the following, replace PROJECT_NAME (twice):

[source,bat]
----
pip install virtualenv
pip install cookiecutter
# pip install pyscaffold pyscaffoldext-cookiecutter
cd {root folder}
putup -i PROJECT_NAME
cd PROJECT_NAME
mkdir src\models
mkdir src\utils
mkdir tools
echo "-e /proj/proj_gruntwurk/gwpycore" > requirements.txt
----

=== GUI Project

[source,bat]
----
echo "kivy # GUI " >> requirements.txt
echo "# kivy # GUI extensions" >> requirements.txt
echo "reportlab # for printing" >> requirements.txt
mkdir src\gui
mkdir src\print
----

=== CLI Project


=== Library Project

[source,bat]
----
cookiecutter https://github.com/audreyfeldroy/cookiecutter-pypackage.git
----

. Edit `setup.cfg` as necessary
. Edit `docs/conf.py` as necessary (for using sphinx to generate API docs).


== Lint

* For imports that appear to be unused but actually are, add `# noqa: F401` to the end of the line.



== Logic Flow

*Ternary* syntax: var = expression if expression else expression

Else-if syntax: *elif*

For/While ... *Else*: The else clause is suppressed if we explicitly break out of the loop

Switch logic (as of 3.10):
----
match value:
    case condition:
        action(s)
----

== Typing

----
isinstance(object, classinfo)
type([]) is list
type({}) is dict
type('') is str
type(0) is int
----

== Numbers

*Integer division* operator: `//`
*Modulo* operator: `%`

*Chaining comparison operators*: `if 5 < x < 15:`



== Dates

=== DateUtils

Details: https://pypi.org/project/python-dateutil/[]

* Relative deltas (next month, next year, next Monday, last week of month, etc) -- both ways
* Flexible recurrence rules
* Generic (fuzzy) parsing of dates in almost any string format
* More

----
from dateutil.parser import parse
logline = 'INFO 2020-01-01T00:00:01 Happy new year, human.'
timestamp = parse(logline, fuzzy=True)
print(timestamp)
# 2020-01-01 00:00:01
----

=== DateTime

`import datetime`

In the following, _dt_ is short for `datetime`:

* dt.MINYEAR
* dt.MAXYEAR
* class dt.date
* class dt.time
* class dt.dt
* class dt.timedelta
* class dt.timezone

All are immutable, hashable, efficiently pickled.

----
class dt.dt(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, fold=0)

classmethod dt.today()
classmethod dt.now()
classmethod dt.fromisoformat(date_string) # YYYY-MM-DD[\*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]] (where * is any single char)
classmethod dt.strptime() -- parse formatted

dt.min # -> dt(MINYEAR, 1, 1, tzinfo=None)
dt.max # -> dt(MAXYEAR, 12, 31, 23, 59, 59, 999999, tzinfo=None).
dt.year
dt.month
dt.day
dt.hour
dt.minute
dt.second
dt.microsecond
dt.tzinfo
dt.fold -> in [0, 1] -- overlapping hour at the end of DST

dt2 = dt1 + timedelta
dt2 = dt1 - timedelta
timedelta = dt1 - dt2
dt1 < dt2

dt.replace(year=self.year, month=self.month, day=self.day, hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, fold=0)
dt.timetuple() # -> time.struct_time((d.year, d.month, d.day, d.hour, d.minute, d.second, d.weekday(), yday, dst))

dt.weekday() # Monday 0 .. Sunday 6
dt.isoweekday() # Monday 1 .. Sunday 7
dt.isocalendar()
dt.isoformat(sep='T', timespec='auto') # -> "YYYY-MM-DDTHH:MM:SS.ffffff"
dt.__str__() # -> dt.isoformat()
dt.ctime()
dt.strftime(format)
dt.__format__(format) # thus f"{dt1:%B %d, %Y}"
----

=== Date Formatting (per the C89 standard)

[width="100%"]
|===
| %a | Weekday abbr                        | Mon..Sun
| %A | Weekday full name                   | Monday..Sunday
| %w | Weekday as a decimal                | 0..6
| %d | Day of month                        | 01..31
| %b | Month abbr                          | Jan..Dec
| %B | Month full name                     | January..December
| %m | Month                               | 01..12
| %y | 2-digit Year                        | 00..99
| %Y | 4-digit Year                        | 0001..9999
| %H | Military Hour                       | 00..23
| %I | Civilian Hour                       | 01..12
| %p | AM/PM                               | AM, PM
| %M | Minute                              | 00..59
| %S | Second                              | 00..59
| %f | Microsecond                         | 000000..999999
| %z | UTC offset                          | (empty), +0000, -0400, +1030, +063415, -030712.345216
| %Z | Time zone name                      | (empty), UTC, EST, CST
| %j | Day of the year                     | 001..366
| %U | Week of the year Sunday based       | 00..53
| %W | Week of the year Monday based       | 00..53
| %c | Locale’s appropriate representation | Tue Aug 16 21:30:00 1988
| %x | Locale’s appropriate representation | 08/16/1988
| %X | Locale’s appropriate representation | 21:30:00
| %% | Percent sign                        | %
|===

Additional Directives:

[width="100%"]
|===
| %G | ISO 8601 year that contains the greater part of the ISO week (%V) | 0001..9999
| %u | ISO 8601 weekday where 1 is Monday                                | 1..7
| %V | ISO 8601 week Monday based where Week 01 contains Jan 4.          | 01..53
|===



== Character Sets

Charset detection with chardet -- pip install chardet



== Strings

=== String Functions


* str.*capitalize*() -- copy of the string with its first character capitalized and the rest lowercased.
* str.*casefold*() -- for caseless matching (slightly more agressive than lower())
* str.*center*/*ljust*/*rjust*(width[, fillchar])
* str.*count*(sub[, start[, end]]) -- number of non-overlapping occurrences of substring sub in the range [start, end].
* str.*encode*(encoding="utf-8", errors="strict")
* str.*expandtabs*(tabsize=8)
* str.*find*/*rfind*(sub[, start[, end]]) -- Only use to determine the position; otherwise use the `in` operator.
* str.*format*(``*``args, ``**``kwargs)
* str.*format_map*(mapping)
* str.*index*/*rindex*(sub[, start[, end]]) -- Like find(), but raise ValueError when the substring is not found.
* str.*isidentifier*() -- Also: Call keyword.iskeyword(str) to test if is a reserved identifier.
* str.*isalnum*()
* str.*isalpha*(), str.*isascii*(), str.*isdecimal*(), str.*isdigit*(), str.*islower*(), str.*isnumeric*(), str.*isprintable*(), str.*isspace*(), str.*istitle*(), str.*isupper*()
* str.*join*(iterable)
* str.*lower*() -- see also *casefold*()
* str.*partition*/*rpartition*(sep) -- Split the string at the first occurrence of sep, and return a 3-tuple containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return a 3-tuple containing the string itself, followed by two empty strings.
* str.*replace*(old, new[, count]) -- a copy of the string with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced. (For Regex replacements, use re.sub().)
* str.*split*/*rsplit*(sep=None, maxsplit=-1) -- breaking the string at word boundaries (sep=None means split on runs of whitespace.)
* str.*splitlines*([keepends]) -- breaking the string at line boundaries. (Use keepend=True to keep the EOL).
* str.*startswith*/*endswith*(prefix[, start[, end]])
* str.*strip*/*lstrip*/*rstrip*([chars]) -- a copy of the string with the leading and trailing characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted or None, the chars argument defaults to removing whitespace. The chars argument is not a prefix or suffix; rather, all combinations of its values are stripped:
* str.*swapcase*() -- a copy of the string with uppercase characters converted to lowercase and vice versa. Note that it is not necessarily true that s.swapcase().swapcase() == s.
* str.*title*() -- a titlecased version of the string
* str.*translate*(table) -- a copy of the string in which each character has been mapped through the given translation table. The table must be an object that implements indexing via __getitem__(), typically a mapping or sequence. When indexed by a Unicode ordinal (an integer), the table object can do any of the following: return a Unicode ordinal or a string, to map the character to one or more other characters; return None, to delete the character from the return string; or raise a LookupError exception, to map the character to itself. You can use str.maketrans() to create a translation map from character-to-character mappings in different formats.
* str.*upper*()
* str.*zfill*(width) -- zero pad

=== String Constants

* string.*ascii_letters* == ascii_lowercase + ascii_uppercase
* string.*ascii_lowercase* -- 'abcdefghijklmnopqrstuvwxyz'
* string.*ascii_uppercase* -- 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
* string.*digits* == '0123456789'
* string.*hexdigits* == '0123456789abcdefABCDEF'
* string.*octdigits* == '01234567'
* string.*punctuation* == `!"#$%&'()*+,-./:;<=>?@[\]^_{|}~`  (plus back tic)
* string.*printable* == digits `+` ascii_letters `+` punctuation + whitespace.
* string.*whitespace* == space, tab, linefeed, return, formfeed, and vertical tab.

=== String Misc.

TODO: Multi-Line Strings vs. """


== RegEx

Details: https://docs.python.org/3/library/re.html[]


* re.*compile*(pattern, flags=0)
* re.*search*(pattern, string, flags=0) -- Any one match
* re.*match*(pattern, string, flags=0) -- Matches at the beginning of string only (regardless of any MULTILINE flag)
* re.*fullmatch*(pattern, string, flags=0) -- Matches the whole string only
* re.*split*(pattern, string, maxsplit=0, flags=0) -- Split using pattern as delimiters. List will include paren captures within the delimiter.
* re.*findall*(pattern, string, flags=0) -- Returns all non-overlapping matches as a list (strings or tuples).
* re.*finditer*(pattern, string, flags=0)
* re.*sub*(pattern, repl, string, count=0, flags=0)
* re.*subn*(pattern, repl, string, count=0, flags=0) -- Same as sub(), but returns a tuple (new_string, number_of_subs_made).
* re.*escape*(pattern) -- converts a string to a pattern
* re.*purge*() -- Clears the regular expression cache.
* Match.*expand*(template) -- do the substitution (with backrefs).
* Match.*group*([group1, ...]), m[group] -- Returns one or more subgroups of the match (string or tuple).
* Match.*groups*(default=None) -- Returns all subgroups as a tuple.
* Match.*groupdict*(default=None) -- Returns a named subgroups
* Match.*start*([group]), Match.end([group]) -- Return the indices of the matched string
* Match.*span*([group]) -- Returns a tuple: (m.start(group), m.end(group)).
* Match.*pos* -- Where the RE engine started looking for a match.
* Match.*endpos* -- Where the RE engine stopped looking for a match.
* Match.*lastindex* -- The integer index of the last matched capturing group, or None if no group was matched at all. For example, the expressions (a)b, ((a)(b)), and ((ab)) will have lastindex == 1 if applied to the string 'ab', while the expression (a)(b) will have lastindex == 2, if applied to the same string.
* Match.*lastgroup* --The name of the last matched capturing group, or None if the group didn’t have a name, or if no group was matched at all.
* Match.*re* -- The regular expression object whose match() or search() method produced this match instance.
* Match.*string* -- The string passed to match() or search().


=== Replacement Backref Modifiers

----
  \l : first character to lower case
  \u : first character to upper case
  \L : start of lower case conversion
  \U : start of upper case conversion
  \E : end lower/upper case conversion
----

=== Flags

----
re.I, re.IGNORECASE, (?i) : Performs case-insensitive matching.
re.M, re.MULTILINE, (?m)  : Caret and dollar match line-by-line.
re.S, re.DOTALL, (?s)     : '.' will match anything INCLUDING a newline.
re.A, re.ASCII, (?a)      : Disables full Unicode matching.
re.DEBUG                  : Displays debug information about compiled expression.
re.L, re.LOCALE, (?L)     : Makes case-insensitive matching dependent on the current locale.
re.X, re.VERBOSE, (?x)    : Allow comments and whitespace in expressions.
----


== Containers/Collections

* List Comprehension: `[ expression for item in list if conditional ]`
* List Comprehension via Generator: `g = (item for item in "hello")` then `print(list(g))`
* Merging dictionaries (Python 3.5+): `merged = { **dict1, **dict2 }`
* Reversing strings and lists: `revstring = "abcdefg"[::-1]`
* Map: `map(function, something_iterable)`
* Unique elements: `set(mylist)`
* Most frequently occurring value: `max(set(test), key = test.count)`
* Counting occurrences: `from collections import Counter`
* List.append(single item)
* List.extend(another list)
* Size: `len(container)`
* Unpacking: a, b, c = (1,2,3)
* Repeat: `two_by_two_array = [[0]*2]*2`
* Zipper: `list_of_tuples = zip(list1, list2, list3)`

=== Sets

s.add(some_new_element)
s.remove(element)
s.update(other_set)
s.union(other_set) (or the vertical bar operator)
s.intersection(other_set) (or the ampersand operator)
s.difference(other_set) (or the minus sign operator)
s.symmetric_difference(other_set) (or the carret operator)
s.isdisjoint(other_set)
s.issubset() (or `<=`, or `<` for a proper subset)
s.issuperset() (or `>=`, or `>` for a proper superset)
len(s)
element in s

=== Sorting

* `lst.sort()` or `sorted(lst)`
* `lst.sort(reverse=True)` or `sorted(lst, reverse=True)`
* `lst.sort(key=lambda x: x[1])` or `sorted(lst, key=fn)`
* For case-insensitive, use `key=str.lower`

=== itertools

`import itertools`

* `iterator = itertools.accumulate(list1, list2)` -- runnning totals
* `iterator = itertools.chain(list1, list2)` -- logical List.extend()
* `iterator = itertools.compress(list1, list2)` -- list1[i] if list2[i]



=== Data Classes

The `@dataclass` decorator automatically adds special methods to a class (only if the method has not been explicitly declared).

`from dataclasses import dataclass`

`@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)`

Details: https://docs.python.org/3/library/dataclasses.html[]


=== Tuples

`Color = namedtuple("Color", "red green blue", defaults=[0,0,0])`

color = Color.make([255,255,255])

=== Dictionaries

* `class dict(**kwarg)`
* `class dict(mapping, **kwarg)`
* `class dict(iterable, **kwarg)`
* `list(d)` -- A list of all the keys used in the dictionary.
* `len(d)` -- The number of items in the dictionary.
* `d[key]` -- Raises a KeyError if key is not in the map and no __missing__ method.
* `d[key] = value`
* `del d[key]` -- Raises a KeyError if key is not in the map.
* `key in d`
* `key not in d`
* `iter(d)` -- An iterator over the keys. Shortcut for iter(d.keys()).
* `clear()`
* `copy()` -- A shallow copy.
* `get(key[, default])` -- never raises a KeyError.
* `items()` A new view (dynamic) of the dictionary’s items ((key, value) pairs).
* `keys()` A new view (dynamic) of the dictionary’s keys.
* `pop(key[, default])` -- If default is not given and key is not in the dictionary, a KeyError is raised.
* `popitem()` -- Remove and return a (key, value) pair from the dictionary. Pairs are returned in LIFO order.
* `reversed(d)` - A reverse iterator over the keys. Shortcut for reversed(d.keys()).
* `setdefault(key[, default])` -- If key is in the dictionary, return its value. If not, add it.
* `update([other])` -- Update the dictionary with the key/value pairs from other.
* `values()` -- A new view (dynamic) of the dictionary’s values.


== Bytes

* bytes type == immutable string
* bytearray type == mutable list

----
value = b'\xf0\xf1\xf2'
value.hex('-') ==> 'f0-f1-f2'
value.hex('_', 2) ==> 'f0_f1f2'
b'UUDDLRLRAB'.hex(' ', -4) ==> '55554444 4c524c52 4142'
----

Instantiating:

* b'' literals
* r'' literals
* bytes(10) -- a zero-filled bytes object of a specified length
* bytes(range(20)) -- from an iterable of integers
* bytes(obj) -- copying existing binary data via the buffer protocol
* bytearray() -- an empty instance
* bytearray(10) -- a zero-filled instance with a given length
* bytearray(range(20)) -- from an iterable of integers
* bytearray(b'Hi!') -- copying existing binary data via the buffer protocol
* bytes.fromhex('FFFF FFFF FFFF')
* bytes.hex()




== Graphics

=== Images

----
pip3 install Pillow
from PIL import Image
im = Image.open("kittens.jpg")
im.show()
(im.format, im.size, im.mode) -> JPEG (1920, 1357) RGB
----

=== Emoji

`pip3 install emoji` -- https://pypi.org/project/emoji/



== pathlib.Path

=== Pure Path Methods

* p / str -- join operator
* p / p -- join operator
* str(p)
* p.parts -- tuple of the path broken down `Path('/usr/bin/python3').parts` -> `('/', 'usr', 'bin', 'python3')`
* p.drive -- string representing the drive letter or name, if any
* p.root -- string representing the (local or global) root, if any
* p.anchor -- concatenation of the drive and root
* p.parents -- immutable sequence providing access to the logical ancestors of the path
* p.parent -- logical parent of the path
* p.name -- string representing the final path component, excluding the drive and root, if any
* p.suffix -- file extension of the final component, if any:
* p.suffixes -- `Path("my/library.tar.gz").suffixes` -> `["tar","gz"]`
* p.stem -- final path component, without its suffix
* p.as_posix() -- string representation of the path with forward slashes (/)
* p.as_uri() -- `Path('/etc/passwd')` -> `file:///etc/passwd`
* p.is_absolute() -- `Path('/a/b').is_absolute()` -> `True`
* p.is_reserved() -- `PureWindowsPath('nul').is_reserved()` -> `True`
* p.joinpath(``*``other) -- same as the join operator
* p.match(pattern) -- glob-style pattern
* p.relative_to(``*``other) -- ValueError raised if impossible
* p.with_name(name) -- new path with the name changed. ValueError raised if original path has no name. `Path('c:/Downloads/pathlib.tar.gz').with_name('setup.py')` -> `Path('c:/Downloads/setup.py')`

=== Concrete Path Methods

* Path.cwd() -- the current directory
* Path.home() -- the user’s home directory
* p.stat() -- os.stat_result object
* p.chmod(mode) -- Change the file mode and permissions
* p.exists() -- file or directory
* p.expanduser() -- new path with expanded ~ and ~user constructs
* p.glob(pattern) -- yields all matching files (of any kind) -> List[Path]
* p.group() -- name of the group owning the file
* p.is_dir() -- True if the path points to a directory (or symlink to one)
* p.is_file() -- True if the path points to a regular file (or symlink to one)
* p.is_mount() True if the path is a mount point
* p.is_symlink()
* p.is_socket()
* p.is_fifo()
* p.is_block_device()
* p.is_char_device()
* p.iterdir() -- When the path points to a directory, yields path objects of the contents (random order)
* p.lchmod(mode) -- of the symbolic link itself
* p.lstat() -- of the symbolic link itself
* p.mkdir(mode=0o777, parents=False, exist_ok=False)
* p.open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)
* p.owner()
* p.read_bytes()
* p.read_text(encoding=None, errors=None)
* p.rename(target) -- rename unless target exists
* p.replace(target) -- rename regardless (clobber any existing target)
* p.resolve(strict=False) -- Make the path absolute, resolving any symlinks. A new path object is returned
* p.rglob(pattern) -- glob() with `**/` prefix assumed (recursive)
* p.rmdir() -- the directory must be empty
* p.samefile(other_path) -- True if points to the same file
* p.symlink_to(target, target_is_directory=False)
* p.unlink(missing_ok=False)
* p.link_to(target) -- create a hard link pointing to a path named target
* p.write_bytes(data)
* p.write_text(data, encoding=None, errors=None)

[width="100%",cols="",options="header"]
|===
| os and os.path            | pathlib
| os.path.abspath()         | Path.resolve()
| os.chmod()                | Path.chmod()
| os.mkdir()                | Path.mkdir()
| os.rename()               | Path.rename()
| os.replace()              | Path.replace()
| os.rmdir()                | Path.rmdir()
| os.remove(), os.unlink()  | Path.unlink()
| os.getcwd()               | Path.cwd()
| os.path.exists()          | Path.exists()
| os.path.expanduser()      | Path.expanduser() and Path.home()
| os.listdir()              | Path.iterdir()
| os.path.isdir()           | Path.is_dir()
| os.path.isfile()          | Path.is_file()
| os.path.islink()          | Path.is_symlink()
| os.link()                 | Path.link_to()
| os.symlink()              | Path.symlink_to()
| os.stat()                 | Path.stat(), Path.owner(), Path.group()
| os.path.isabs()           | PurePath.is_absolute()
| os.path.join()            | PurePath.joinpath()
| os.path.basename()        | PurePath.name
| os.path.dirname()         | PurePath.parent
| os.path.samefile()        | Path.samefile()
| os.path.splitext()        | PurePath.suffix
|===

NOTE: Although os.path.relpath() and PurePath.relative_to() have some overlapping use-cases, their semantics differ enough to warrant not considering them equivalent.

=== High-Level Directory and File Operations

In the following, src and dst can be a str or Path.

* shutil.copyfileobj(fsrc, fdst[, length])
* shutil.copyfile(src, dst, *, follow_symlinks=True)
* shutil.copymode(src, dst, *, follow_symlinks=True) -- Copy the permission bits
* shutil.copystat(src, dst, *, follow_symlinks=True) -- Copy the permission bits, timestamps, and flags
* shutil.copy(src, dst, *, follow_symlinks=True) -- dst can be a directory
* shutil.copy2(src, dst, *, follow_symlinks=True) -- attempts to preserve file metadata
* shutil.ignore_patterns(*patterns) -- creates a function that can be passed in to copytree()
* shutil.copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False, dirs_exist_ok=False) -- Recursively copy an entire directory tree rooted at src to a directory named dst and return the destination directory.
* shutil.rmtree(path, ignore_errors=False, onerror=None) -- Delete a directory tree
* shutil.move(src, dst, copy_function=copy2) = Recursively move a file or directory
* shutil.disk_usage(path) -- disk usage statistics about the given path -> named tuple (total, used, free)
* shutil.chown(path, user=None, group=None)
* shutil.which(cmd, mode=os.F_OK | os.X_OK, path=None) -- executable which would be run

=== Archiving (zip, tar)

shutil.make_archive(base_name, format[, root_dir[, base_dir[, verbose[, dry_run[, owner[, group[, logger]]]]]]]) -- Create an archive (zip, tar...) -> name: str.
shutil.get_archive_formats() -> List of tuples (name, description)
shutil.register_archive_format(name, function[, extra_args[, description]])
shutil.unregister_archive_format(name)
shutil.unpack_archive(filename[, extract_dir[, format]])
shutil.register_unpack_format(name, extensions, function[, extra_args[, description]])
shutil.unregister_unpack_format(name)
shutil.get_unpack_formats()


== Console

shutil.get_terminal_size(fallback=(columns, lines)) -> named tuple of type os.terminal_size



== Internet

=== Quickly Create a Web Server

You can quickly start a web server, serving the contents of the current directory:
`python3 -m http.server`


=== Beautiful Soup


== Error Handling

=== Built-In Error and Warning Exceptions

These all descend from `Exception` (which inherits from `BaseException`).
User-defined errors should descend from `Exception`.
User-defined warnings should descend from `UserWarning`.

* StopIteration, StopAsyncIteration
* ArithmeticError => FloatingPointError, OverflowError, ZeroDivisionError
* AssertionError
* AttributeError
* BufferError
* EOFError
* ImportError => ModuleNotFoundError
* LookupError => IndexError, KeyError
* MemoryError
* NameError => UnboundLocalError
* OSError =>
** BlockingIOError
** ChildProcessError
** ConnectionError => BrokenPipeError, ConnectionAbortedError, ConnectionRefusedError, ConnectionResetError
** FileExistsError
** FileNotFoundError
** InterruptedError
** IsADirectoryError
** NotADirectoryError
** PermissionError
** ProcessLookupError
** TimeoutError
* ReferenceError
* RuntimeError => NotImplementedError, RecursionError
* SyntaxError => IndentationError => TabError
* SystemError
* TypeError
* ValueError => UnicodeError = > UnicodeDecodeError, UnicodeEncodeError, UnicodeTranslateError
* Warning =>
** *UserWarning* -- _base class for user-defined warnings._
** RuntimeWarning
** FutureWarning, DeprecationWarning, PendingDeprecationWarning
** SyntaxWarning, ImportWarning
** UnicodeWarning
** BytesWarning
** EncodingWarning
** ResourceWarning

=== Built-In Exception-like SIGNALs

These all inherit directly from BaseException.

* SystemExit
* KeyboardInterrupt
* GeneratorExit



Details: https://beautiful-soup-4.readthedocs.io/en/latest/[]
